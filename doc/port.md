# 移植指南
### KLite移植指南(2018.07.17)
#### 1.概述
    KLite核心代码完全使用C语言实现，由于不同CPU平台的差异性，
    对于与CPU平台有关的功能，无法使用相同的代码实现。
    这些无法统一实现的函数，系统提供了一个头文件定义了所有需要适配的函数接口，
    这个文件在source/kernel/port.h
    目前一共需要实现以下6个函数接口：
```
    void cpu_os_init(void);
    void cpu_os_start(void);
    void cpu_irq_enable(void);
    void cpu_irq_disable(void);
    void cpu_tcb_init(struct tcb *tcb);
    void cpu_tcb_switch(void);
```
    除此之外，还需要为系统提供一个滴答时钟。
    滴答时钟使用硬件定时器中断，中断周期通常为1ms，也可以为其它任意值。
    只需要在中断服务程序中调用一次kernel_timetick(1)即可。
    这里的参数1则代表时钟周期，如果是10ms中断一次，则应该传入10作为参数。
    

#### 2.函数说明
-------------------------------------------------------------------------------
    void cpu_os_init(void)
    这个函数在系统初始化的时候调用。
    可以用于初始化系统时钟或其它必要的初始化。
    
-------------------------------------------------------------------------------
    void cpu_os_start(void)
    这个函数在系统启动的时候调用。
    可以用于配置系统滴答时钟和系统相关的中断等。
    
-------------------------------------------------------------------------------
    void cpu_irq_disable(void)
    这个函数用于关闭CPU中断。
    需要屏蔽所有对系统可能产生竞争风险的中断。
    也可以简单处理，直接屏蔽所有中断。
    
-------------------------------------------------------------------------------
    void cpu_irq_enable(void)
    这个函数用于使能CPU中断
    恢复所有被cpu_irq_diable屏蔽的中断。
    
-------------------------------------------------------------------------------
    void cpu_tcb_init(struct tcb *tcb)
    这个函数用于初始化线程上下文。
    每当创建线程的时候，都会调用此函数，对线程的上下文进行初始化。
    参数tcb包含了线程上下文属性，这个函数可能用到tcb的以下几个成员：
    tcb->sp_min  //新线程的栈空间的起始地址
    tcb->sp_max  //新线程的栈空间的结束地址
    tcb->entry   //新线程的入口函数地址
    tcb->arg     //新线程的入口函数参数
    tcb->sp      //新线程的栈顶地址
    移植这个函数时，需要实现以下功能：
    根据sp_min和sp_max的值，确定栈顶的地址，取决于目标CPU平台的堆栈增长方向。
    并把entry和arg参数按照正确的顺序压入堆栈；为了实现线程结束时自己释放空间，
    还需要把thread_exit函数的地址作为线程函数的返回地址正确地压入栈，
    最后把新的栈顶地址保存到tcb->sp。
    
-------------------------------------------------------------------------------
    void cpu_tcb_switch(void)
    这个函数用于切换上下文，通常用汇编代码实现。
    上下文切换的目标对象已经定义在全局变量，分别是：
    sched_tcb_now //当前线程上下文指针，将要被新线程取代
    sched_tcb_new //新的线程上下文指针，将要取代当前线程
    具体地，首先要判断sched_tcb_now是否为空指针，因为系统初始化的时候没有当前线程。
    如果为空指针，则跳过保存上下文的过程，直接恢复新的线程上下文。
    如果不为空指针，则先将当前CPU的上下文保存，再恢复新的线程上下文。
    最后再执行sched_tcb_now = sched_tcb_new。
    
    上下文保存方法：
    将当前CPU的所有上下文寄存器，按照特定的顺序压入当前线程的堆栈，
    并将当前更新后的栈顶地址保存到sched_tcb_now->sp成员。
    上下文恢复方法：
    将sched_tcb_new->sp成员的读出，作为当前的堆栈，并按照压栈的顺序，
    将上下文寄存器从堆栈中弹出。
    
#### 3.参数示例
    详见源代码。
    source/port/port.c
    source/port/cortex-m3/cpu.c
    source/port/cortex-m3/cpu_asm_gcc.s
    